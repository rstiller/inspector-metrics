<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>inspector-metrics documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">inspector-metrics documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>MetricSetReportContext</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>lib/metrics/reporter/metric-reporter.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Helper interface for reporting runs.</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#date">date</a>
                                </li>
                                <li>
                                        <a href="#metrics">metrics</a>
                                </li>
                                <li>
                                        <a href="#overallCtx">overallCtx</a>
                                </li>
                                <li>
                                        <a href="#registry">registry</a>
                                </li>
                                <li>
                                        <a href="#type">type</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="date"></a>
                                        <span class="name"><b>date</b><a href="#date"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>date:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The current date.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="metrics"></a>
                                        <span class="name"><b>metrics</b><a href="#metrics"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>metrics:     <code>M[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>M[]</code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The array of metric instance that is currently reported.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="overallCtx"></a>
                                        <span class="name"><b>overallCtx</b><a href="#overallCtx"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>overallCtx:     <code><a href="../interfaces/OverallReportContext.html" target="_self" >OverallReportContext</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/OverallReportContext.html" target="_self" >OverallReportContext</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The OverallReportContext this context is running in.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="registry"></a>
                                        <span class="name"><b>registry</b><a href="#registry"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>registry:     <code><a href="../interfaces/Metric.html" target="_self" >MetricRegistry</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/Metric.html" target="_self" >MetricRegistry</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The registry the metric are registered in.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="type"></a>
                                        <span class="name"><b>type</b><a href="#type"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>type:     <code><a href="../interfaces/Metric.html" target="_self" >MetricType</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/Metric.html" target="_self" >MetricType</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The type of the metrics in the <a href="#metrics">#metrics</a> array.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import &quot;source-map-support/register&quot;;

import { Clock } from &quot;../clock&quot;;
import { Counter, MonotoneCounter } from &quot;../counter&quot;;
import { Event } from &quot;../event&quot;;
import { Gauge } from &quot;../gauge&quot;;
import { Histogram } from &quot;../histogram&quot;;
import { Meter } from &quot;../meter&quot;;
import { Metric } from &quot;../metric&quot;;
import { MetricRegistry } from &quot;../metric-registry&quot;;
import { Taggable } from &quot;../taggable&quot;;
import { MILLISECOND, MINUTE } from &quot;../time-unit&quot;;
import { Timer } from &quot;../timer&quot;;
import { MetricEntry } from &quot;./metric-entry&quot;;
import { MetricType } from &quot;./metric-type&quot;;

/**
 * Helper interface for handling tags.
 */
export interface Tags {
    [key: string]: string;
}

/**
 * Helper interface for a reporting run.
 */
export interface OverallReportContext {
    [key: string]: any;
}

/**
 * Helper interface for reporting runs.
 */
export interface MetricSetReportContext&lt;M&gt; {
    /**
     * The OverallReportContext this context is running in.
     *
     * @type {OverallReportContext}
     * @memberof ReportingContext
     */
    overallCtx: OverallReportContext;
    /**
     * The array of metric instance that is currently reported.
     *
     * @type {M[]}
     * @memberof ReportingContext
     */
    metrics: M[];
    /**
     * The registry the metric are registered in.
     *
     * @type {MetricRegistry}
     * @memberof ReportingContext
     */
    readonly registry: MetricRegistry;
    /**
     * The current date.
     *
     * @type {Date}
     * @memberof ReportingContext
     */
    readonly date: Date;
    /**
     * The type of the metrics in the {@link #metrics} array.
     *
     * @type {MetricType}
     * @memberof ReportingContext
     */
    readonly type: MetricType;
}

/**
 * Helper interface for reporting results.
 */
export interface ReportingResult&lt;M, T&gt; {
    /**
     * The metric the result refers to.
     *
     * @type {M}
     * @memberof ReportingResult
     */
    readonly metric: M;
    /**
     * The reporting result - implementation specific.
     *
     * @type {T}
     * @memberof ReportingResult
     */
    readonly result: T;
}

/**
 * Options for the {@link MetricReporter}.
 *
 * @export
 * @interface MetricReporterOptions
 */
export interface MetricReporterOptions {
    /**
     * Clock used to determine the date for the reporting as well as the minimum-reporting timeout feature.
     *
     * @type {Clock}
     * @memberof MetricReporterOptions
     */
    readonly clock?: Clock;
    /**
     * Timeout in minutes a metric need to be included in the report without having changed.
     *
     * @type {number}
     * @memberof MetricReporterOptions
     */
    minReportingTimeout?: number;
    /**
     * Tags for this reporter instance - to be combined with the tags of each metric while reporting.
     *
     * @type {Map&lt;string, string&gt;}
     * @memberof MetricReporterOptions
     */
    tags?: Map&lt;string, string&gt;;
}

/**
 * Interface for metric-reporter.
 *
 * @export
 * @interface IMetricReporter
 */
export interface IMetricReporter {
    /**
     * Gets the reporter tags.
     *
     * @returns {Map&lt;string, string&gt;}
     * @memberof IMetricReporter
     */
    getTags(): Map&lt;string, string&gt;;

    /**
     * Sets the reporter tags.
     *
     * @param {Map&lt;string, string&gt;} tags
     * @returns {this}
     * @memberof IMetricReporter
     */
    setTags(tags: Map&lt;string, string&gt;): this;

    /**
     * Implementations start reporting metrics when called.
     *
     * @abstract
     * @returns {Promise&lt;this&gt;}
     * @memberof IMetricReporter
     */
    start(): Promise&lt;this&gt;;

    /**
     * Implementations stop reporting metrics when called.
     *
     * @abstract
     * @returns {Promise&lt;this&gt;}
     * @memberof IMetricReporter
     */
    stop(): Promise&lt;this&gt;;

    /**
     * Adds a new {@link MetricRegistry} to be reported.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof IMetricReporter
     */
    addMetricRegistry(metricRegistry: MetricRegistry): this;

    /**
     * Removes the given {@link MetricRegistry} if it was previously added.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof IMetricReporter
     */
    removeMetricRegistry(metricRegistry: MetricRegistry): this;

    /**
     * Reports an {@link Event}.
     *
     * Implementations can choose how to process ad-hoc events, wether it&#x27;s
     * queuing the events to the next call to report or sending events
     * immediately.
     *
     * Also the usual reporting process of calling {@link #beforeReport}, do the reporting
     * and call {@link #afterReport} may not be applied for ad-hoc events.
     *
     * This implementation does nothing and always resolved the specified evnet.
     *
     * @param {MetricRegistry} event
     * @returns {this}
     * @memberof IMetricReporter
     */
    reportEvent&lt;TEventData, TEvent extends Event&lt;TEventData&gt;&gt;(event: TEvent): Promise&lt;TEvent&gt;;

    /**
     * Sends events remaining in the queue (if a queue is used in the implementation).
     *
     * @returns {Promise&lt;void&gt;}
     * @memberof IMetricReporter
     */
    flushEvents(): Promise&lt;void&gt;;
}

/**
 * Base-class for metric-reporter implementations.
 *
 * @export
 * @abstract
 * @class MetricReporter
 */
export abstract class MetricReporter&lt;O extends MetricReporterOptions, T&gt; implements IMetricReporter {

    /**
     * {@link MetricRegistry} instances.
     *
     * @protected
     * @type {MetricRegistry[]}
     * @memberof MetricReporter
     */
    protected readonly metricRegistries: MetricRegistry[] &#x3D; [];
    /**
     * options for this reporter instance.
     *
     * @protected
     * @type {O}
     * @memberof MetricReporter
     */
    protected readonly options: O;
    /**
     * Keeps track of the reporting states for each metric.
     *
     * @protected
     * @type {Map&lt;number, MetricEntry&gt;}
     * @memberof MetricReporter
     */
    protected readonly metricStates: Map&lt;number, MetricEntry&gt; &#x3D; new Map();

    /**
     * Creates an instance of MetricReporter.
     *
     * @param {O} options
     * @param {Map&lt;string, string&gt;} [tags&#x3D;new Map()]
     *          tags for this reporter instance - to be combined with the tags of each metric while reporting
     * @param {Clock} [clock&#x3D;new StdClock()]
     *          clock used to determine the date for the reporting as well as the minimum-reporting timeout feature
     * @param {number} [minReportingTimeout&#x3D;1]
     *          timeout in minutes a metric need to be included in the report without having changed
     * @memberof MetricReporter
     */
    public constructor(options: O) {
        this.options &#x3D; options;
    }

    /**
     * Gets the reporter tags.
     *
     * @returns {Map&lt;string, string&gt;}
     * @memberof MetricReporter
     */
    public getTags(): Map&lt;string, string&gt; {
        return this.options.tags;
    }

    /**
     * Sets the reporter tags.
     *
     * @param {Map&lt;string, string&gt;} tags
     * @returns {this}
     * @memberof MetricReporter
     */
    public setTags(tags: Map&lt;string, string&gt;): this {
        this.options.tags &#x3D; tags;
        return this;
    }

    /**
     * Implementations start reporting metrics when called.
     *
     * @abstract
     * @returns {Promise&lt;this&gt;}
     * @memberof MetricReporter
     */
    public abstract start(): Promise&lt;this&gt;;

    /**
     * Implementations stop reporting metrics when called.
     *
     * @abstract
     * @returns {Promise&lt;this&gt;}
     * @memberof MetricReporter
     */
    public abstract stop(): Promise&lt;this&gt;;

    /**
     * Adds a new {@link MetricRegistry} to be reported.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof MetricReporter
     */
    public addMetricRegistry(metricRegistry: MetricRegistry): this {
        this.metricRegistries.push(metricRegistry);
        return this;
    }

    /**
     * Removes the given {@link MetricRegistry} if it was previously added.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof MetricReporter
     */
    public removeMetricRegistry(metricRegistry: MetricRegistry): this {
        const index: number &#x3D; this.metricRegistries.indexOf(metricRegistry);
        if (index &gt; -1) {
            this.metricRegistries.splice(index, 1);
        }
        return this;
    }

    /**
     * Reports an {@link Event}.
     *
     * Implementations can choose how to process ad-hoc events, wether it&#x27;s
     * queuing the events to the next call to report or sending events
     * immediately.
     *
     * Also the usual reporting process of calling {@link #beforeReport}, do the reporting
     * and call {@link #afterReport} may not be applied for ad-hoc events.
     *
     * This implementation does nothing and always resolved the specified event.
     *
     * @param {Event} event
     * @returns {Promise&lt;TEvent&gt;}
     * @memberof MetricReporter
     */
    public async reportEvent&lt;TEventData, TEvent extends Event&lt;TEventData&gt;&gt;(event: TEvent): Promise&lt;TEvent&gt; {
        return event;
    }

    /**
     * Sends events remaining in the queue (if a queue is used in the implementation).
     *
     * @returns {Promise&lt;void&gt;}
     * @memberof MetricReporter
     */
    public async flushEvents(): Promise&lt;void&gt; {
    }

    /**
     * Called be before each reporting run.
     *
     * @protected
     * @memberof MetricReporter
     */
    protected async beforeReport(ctx: OverallReportContext) {
    }

    /**
     * Called after each reporting run.
     *
     * @protected
     * @memberof MetricReporter
     */
    protected async afterReport(ctx: OverallReportContext) {
    }

    /**
     * Run the reporting procedures. Calls {@link #beforeReport} before each
     * {@link MetricRegistry}&#x27;s metrics are reported and {@link #afterReport}
     * afterwards.
     *
     * @protected
     * @memberof MetricReporter
     */
    protected async report(): Promise&lt;OverallReportContext&gt; {
        if (this.metricRegistries &amp;&amp; this.metricRegistries.length &gt; 0) {
            const ctx &#x3D; this.createOverallReportContext();
            await this.beforeReport(ctx);
            for (const registry of this.metricRegistries) {
                await this.reportMetricRegistry(ctx, registry);
            }
            await this.afterReport(ctx);
            return ctx;
        }
        return {};
    }

    /**
     * Reporting function for a sinlge {@link MetricRegistry}.
     * Calls {@link #createReportingContext} for each metric type.
     * Afterwarsds calls {@link #reportMetrics} for each of the
     * registry&#x27;s metrics - grouped by type.
     * And finally calls {@link #handleResults} for each of the results.
     *
     * @protected
     * @param {MetricRegistry} registry
     * @memberof MetricReporter
     */
    protected async reportMetricRegistry(ctx: OverallReportContext, registry: MetricRegistry) {
        const date: Date &#x3D; new Date(this.options.clock.time().milliseconds);
        const counterCtx: MetricSetReportContext&lt;MonotoneCounter | Counter&gt; &#x3D; this
            .createMetricSetReportContext(ctx, registry, date, &quot;counter&quot;);
        const gaugeCtx: MetricSetReportContext&lt;Gauge&lt;any&gt;&gt; &#x3D; this
            .createMetricSetReportContext(ctx, registry, date, &quot;gauge&quot;);
        const histogramCtx: MetricSetReportContext&lt;Histogram&gt; &#x3D; this
            .createMetricSetReportContext(ctx, registry, date, &quot;histogram&quot;);
        const meterCtx: MetricSetReportContext&lt;Meter&gt; &#x3D; this
            .createMetricSetReportContext(ctx, registry, date, &quot;meter&quot;);
        const timerCtx: MetricSetReportContext&lt;Timer&gt; &#x3D; this
            .createMetricSetReportContext(ctx, registry, date, &quot;timer&quot;);

        counterCtx.metrics &#x3D; registry.getMonotoneCounterList();
        const monotoneCounterResults &#x3D; this.reportMetrics(ctx, counterCtx,
            (counter: MonotoneCounter) &#x3D;&gt; this.reportCounter(counter, counterCtx),
            (counter: MonotoneCounter) &#x3D;&gt; counter.getCount());

        counterCtx.metrics &#x3D; registry.getCounterList();
        const counterResults &#x3D; this.reportMetrics(ctx, counterCtx as MetricSetReportContext&lt;Counter&gt;,
            (counter: Counter) &#x3D;&gt; this.reportCounter(counter, counterCtx),
            (counter: Counter) &#x3D;&gt; counter.getCount());

        gaugeCtx.metrics &#x3D; registry.getGaugeList();
        const gaugeResults &#x3D; this.reportMetrics(ctx, gaugeCtx,
            (gauge: Gauge&lt;any&gt;) &#x3D;&gt; this.reportGauge(gauge, gaugeCtx),
            (gauge: Gauge&lt;any&gt;) &#x3D;&gt; gauge.getValue());

        histogramCtx.metrics &#x3D; registry.getHistogramList();
        const histogramResults &#x3D; this.reportMetrics(ctx, histogramCtx,
            (histogram: Histogram) &#x3D;&gt; this.reportHistogram(histogram, histogramCtx),
            (histogram: Histogram) &#x3D;&gt; histogram.getCount());

        meterCtx.metrics &#x3D; registry.getMeterList();
        const meterResults &#x3D; this.reportMetrics(ctx, meterCtx,
            (meter: Meter) &#x3D;&gt; this.reportMeter(meter, meterCtx),
            (meter: Meter) &#x3D;&gt; meter.getCount());

        timerCtx.metrics &#x3D; registry.getTimerList();
        const timerResults &#x3D; this.reportMetrics(ctx, timerCtx,
            (timer: Timer) &#x3D;&gt; this.reportTimer(timer, timerCtx),
            (timer: Timer) &#x3D;&gt; timer.getCount());

        await this.handleResults(ctx, registry, date, &quot;counter&quot;, monotoneCounterResults);
        await this.handleResults(ctx, registry, date, &quot;counter&quot;, counterResults);
        await this.handleResults(ctx, registry, date, &quot;gauge&quot;, gaugeResults);
        await this.handleResults(ctx, registry, date, &quot;histogram&quot;, histogramResults);
        await this.handleResults(ctx, registry, date, &quot;meter&quot;, meterResults);
        await this.handleResults(ctx, registry, date, &quot;timer&quot;, timerResults);
    }

    /**
     * Creates an OverallReportContext.
     *
     * @protected
     * @returns {OverallReportContext}
     * @memberof MetricReporter
     */
    protected createOverallReportContext(): OverallReportContext {
        return {
        };
    }

    /**
     * Creates a MetricSetReportContext with the specified arguments.
     *
     * @protected
     * @param {OverallReportContext} overallCtx
     * @param {MetricRegistry} registry
     * @param {Date} date
     * @param {MetricType} type
     * @returns {MetricSetReportContext&lt;any&gt;}
     * @memberof MetricReporter
     */
    protected createMetricSetReportContext(
        overallCtx: OverallReportContext,
        registry: MetricRegistry,
        date: Date,
        type: MetricType): MetricSetReportContext&lt;any&gt; {
        return {
            date,
            metrics: [],
            overallCtx,
            registry,
            type,
        };
    }

    /**
     * Filters out each metric that does not necessarily need to be reported
     * and calls the specified reporting function for the remaining.
     *
     * @protected
     * @template M type of the metric
     * @template C typed ReportingContext
     * @param {C} ctx
     * @param {(metric: M, ctx: C) &#x3D;&gt; T} reportFunction
     * @param {(metric: M, ctx: C) &#x3D;&gt; number} lastModifiedFunction
     * @returns {Array&lt;ReportingResult&lt;M, T&gt;&gt;}
     * @memberof MetricReporter
     */
    protected reportMetrics&lt;M extends Metric, C extends MetricSetReportContext&lt;M&gt;&gt;(
        overallCtx: OverallReportContext,
        ctx: C,
        reportFunction: (metric: M, ctx: C) &#x3D;&gt; T,
        lastModifiedFunction: (metric: M, ctx: C) &#x3D;&gt; number): Array&lt;ReportingResult&lt;M, T&gt;&gt; {

        return ctx.metrics
            .filter((metric) &#x3D;&gt; {
                const metricId &#x3D; (metric as any).id;
                return !metricId || this.hasChanged(metricId, lastModifiedFunction(metric, ctx), ctx.date.getTime());
            })
            .map((metric) &#x3D;&gt; ({
                metric,
                result: reportFunction(metric, ctx),
            }))
            .filter((result) &#x3D;&gt; !!result.result);
    }

    /**
     * Handles the reporting result for a group of metric instances.
     *
     * @protected
     * @abstract
     * @param {OverallReportContext} ctx
     * @param {MetricRegistry} registry
     * @param {Date} date
     * @param {MetricType} type
     * @param {Array&lt;ReportingResult&lt;any, T&gt;&gt;} results
     * @returns {Promise&lt;void&gt;}
     * @memberof MetricReporter
     */
    protected abstract handleResults(
        ctx: OverallReportContext,
        registry: MetricRegistry,
        date: Date,
        type: MetricType,
        results: Array&lt;ReportingResult&lt;any, T&gt;&gt;): Promise&lt;void&gt;;

    /**
     * Does the reporting for a counter or monotone counter.
     *
     * @protected
     * @abstract
     * @param {(MonotoneCounter | Counter)} counter
     * @param {(MetricSetReportContext&lt;MonotoneCounter | Counter&gt;)} ctx
     * @returns {T}
     * @memberof MetricReporter
     */
    protected abstract reportCounter(
        counter: MonotoneCounter | Counter, ctx: MetricSetReportContext&lt;MonotoneCounter | Counter&gt;): T;

    /**
     * Does the reporting for a gauge.
     *
     * @protected
     * @abstract
     * @param {Gauge&lt;any&gt;} gauge
     * @param {MetricSetReportContext&lt;Gauge&lt;any&gt;&gt;} ctx
     * @returns {T}
     * @memberof MetricReporter
     */
    protected abstract reportGauge(gauge: Gauge&lt;any&gt;, ctx: MetricSetReportContext&lt;Gauge&lt;any&gt;&gt;): T;

    /**
     * Does the reporting for a histogram.
     *
     * @protected
     * @abstract
     * @param {Histogram} histogram
     * @param {MetricSetReportContext&lt;Histogram&gt;} ctx
     * @returns {T}
     * @memberof MetricReporter
     */
    protected abstract reportHistogram(histogram: Histogram, ctx: MetricSetReportContext&lt;Histogram&gt;): T;

    /**
     * Does the reporting for a meter.
     *
     * @protected
     * @abstract
     * @param {Meter} meter
     * @param {MetricSetReportContext&lt;Meter&gt;} ctx
     * @returns {T}
     * @memberof MetricReporter
     */
    protected abstract reportMeter(meter: Meter, ctx: MetricSetReportContext&lt;Meter&gt;): T;

    /**
     * Does the reporting for a timer.
     *
     * @protected
     * @abstract
     * @param {Timer} timer
     * @param {MetricSetReportContext&lt;Timer&gt;} ctx
     * @returns {T}
     * @memberof MetricReporter
     */
    protected abstract reportTimer(timer: Timer, ctx: MetricSetReportContext&lt;Timer&gt;): T;

    /**
     * Determines if a metric instance has changed it&#x27;s value since the last check.
     * This is always true if the minimal-reporting timeout was reached.
     *
     * @private
     * @param {number} metricId
     * @param {number} lastValue
     * @param {number} date
     * @returns {boolean}
     * @memberof MetricReporter
     */
    protected hasChanged(metricId: number, lastValue: number, date: number): boolean {
        let changed &#x3D; true;
        let metricEntry &#x3D; {
            lastReport: 0,
            lastValue,
        };
        if (this.metricStates.has(metricId)) {
            metricEntry &#x3D; this.metricStates.get(metricId);
            changed &#x3D; metricEntry.lastValue !&#x3D;&#x3D; lastValue;
            if (!changed) {
                const minReportingTimeout &#x3D; MINUTE.convertTo(this.options.minReportingTimeout, MILLISECOND);
                changed &#x3D; metricEntry.lastReport + minReportingTimeout &lt; date;
            }
        }
        if (changed) {
            metricEntry.lastReport &#x3D; date;
            metricEntry.lastValue &#x3D; lastValue;
        }
        this.metricStates.set(metricId, metricEntry);
        return changed;
    }

    /**
     * Combines the tags of this reporter instance, the specified {@link MetricRegistry}
     * and the specified taggable metric (in this order).
     *
     * @protected
     * @param {MetricRegistry} registry
     * @param {Taggable} taggable
     * @returns {Tags}
     * @memberof MetricReporter
     */
    protected buildTags(registry: MetricRegistry, taggable: Taggable): Tags {
        const tags: Tags &#x3D; {};
        if (this.options.tags) {
            this.options.tags.forEach((tag, key) &#x3D;&gt; tags[key] &#x3D; tag);
        }
        if (registry &amp;&amp; registry.getTags()) {
            registry.getTags().forEach((tag, key) &#x3D;&gt; tags[key] &#x3D; tag);
        }
        if (taggable.getTags()) {
            taggable.getTags().forEach((tag, key) &#x3D;&gt; tags[key] &#x3D; tag);
        }
        return tags;
    }

    /**
     * Checks the number and gives it back or zero (0) if it&#x27;s not a number.
     *
     * @protected
     * @param {number} value
     * @returns {number}
     * @memberof MetricReporter
     */
    protected getNumber(value: number): number {
        if (isNaN(value)) {
            return 0;
        }
        return value;
    }

}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'MetricSetReportContext.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
